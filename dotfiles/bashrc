# .bashrc

# Source global definitions
if [ -f /etc/bashrc ]; then
	. /etc/bashrc
fi

# https://www.digitalocean.com/community/tutorials/how-to-use-bash-history-commands-and-expansions-on-a-linux-vps
HISTTIMEFORMAT="%Y-%b-%d %T "

# https://www.happyassassin.net/2015/01/16/bash-history-with-multiple-sessions/
HISTSIZE=1048576
HISTFILESIZE=1048576

LAST_HISTORY_WRITE=$SECONDS
function prompt_command {
	if [ $(($SECONDS - $LAST_HISTORY_WRITE)) -gt 60 ]; then
		history -a && history -c && history -r
		LAST_HISTORY_WRITE=$SECONDS
	fi
}

PROMPT_COMMAND="$PROMPT_COMMAND; prompt_command"

# Uncomment the following line if you don't like systemctl's auto-paging feature:
# export SYSTEMD_PAGER=

# User specific aliases and functions
alias sshq="ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
alias scpq="scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
alias sshk="ssh -o PreferredAuthentications=keyboard-interactive,password -o PubkeyAuthentication=no -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"

# unset USER/USERNAME to work with keystoneclient (but why?!?!?!)
unset USER
unset USERNAME

# Default to CI-RHOS Testing tenant
source ~/rhos-testing.sh

# Unset all the OpenStack vars
# https://stackoverflow.com/a/5976494/6257168
function UnsetOpenStack()
{
	for i in $(echo "${!OS_*}"); do
		unset $i
	done
}
alias unset-openstack=UnsetOpenStack

# Choose Openstack instance/tenant
alias osp7="UnsetOpenStack; source ~/osp7.sh"
alias osp7-testing="UnsetOpenStack; source ~/osp7-testing.sh"
alias docker-jenkins="UnsetOpenStack; source ~/docker-jekins.sh"
alias rhos="UnsetOpenStack; source ~/rhos.sh"
alias rhos-testing="UnsetOpenStack; source ~/rhos-testing.sh"

# Clean up QEOS floating IP
function NovaCleanIPs()
{
	nova floating-ip-list | awk '{print $2,$6}' | grep '-' | awk '{print $1}' | xargs -i nova floating-ip-delete {}
}
alias nova-clean-ips=NovaCleanIPs

# Clean up QEOS images
function NovaCleanImages()
{
	nova list | grep $1 | awk '{print $2}' | xargs -i nova delete {}
}
alias nova-clean-images=NovaCleanImages

# Flush ARP cache
alias flush-arp="ip -s -s neigh flush all"

# Delete VM from resources.json file
# TODO: error checking for names not in OS instance
# TODO: error checking for floating IPs not in OS instance
# TODO: handle multiple floating IPs
function NovaDeleteRes()
{
	if [ $# -eq 0 ]; then
		RES='resources.json'
	else
		RES="$1"
	fi
	VM=`grep name $RES | cut -d '"' -f4`
	VMIP=`grep ip $RES | cut -d '"' -f4`
	nova floating-ip-disassociate $VM $VMIP
	nova delete $VM
}

alias nova-delete-res=NovaDeleteRes
# Use 'sudo' with aliases
# http://askubuntu.com/a/22043
alias sudo="sudo "

# Retrieve the IP address for a VM
function GetVmIp()
{
	MAC=`sudo virsh dumpxml $1 | grep 'mac address' | awk -F\' '{print $2}'`
	ip neigh | grep $MAC | awk '{print $1}'
}
alias get-vm-ip=GetVmIp

# Free up cached memory
# http://www.yourownlinux.com/2013/10/how-to-free-up-release-unused-cached-memory-in-linux.html
# https://web.archive.org/web/*/http://www.yourownlinux.com/2013/10/how-to-free-up-release-unused-cached-memory-in-linux.html
function FreeCachedMem()
{
	echo 1 > /proc/sys/vm/drop_caches
	echo 2 > /proc/sys/vm/drop_caches
	echo 3 > /proc/sys/vm/drop_caches
	sync
}
alias free-mem=FreeCachedMem

# setup for rcm_messages
export KRB5CCNAME=/tmp/krb5cc_miabbott

# nova cleanup stub code
# nova list | awk 'NR>3 {print $2}' | xargs -i nova show {} | awk '/created/ {print $4}'
# 1. list all instances
# 2. print out ids
# 3. show details
# 4. print out creation date

alias vmlist="sudo virsh list --all"

# YAML Lint
#alias yamllint="ruby -e \"require 'yaml'; YAML.load_file('$1')\""

# Turn on/off http proxy
function HttpProxyOn()
{
	export http_proxy=http://localhost:8123
	export https_proxy=http://localhost:8123
}
alias proxyon=HttpProxyOn

function HttpProxyOff()
{
	unset http_proxy
	unset https_proxy
}
alias proxyoff=HttpProxyOff

# Alias to start simple tmux session
function StartTmux()
{
	tmux new-session -d -n htop htop
	tmux -2 attach-session -d
}
alias start-tmux=StartTmux

# disable ctrl-s - suspend terminal
stty -ixon

# Define default LIBVIRT connection
export LIBVIRT_DEFAULT_URI=qemu:///system

# Putting this here because I don't have an Ansible playbook to setup my workstation
#$ sudo cat /etc/polkit-1/rules.d/80-libvirt-manage.rules
#// https://goldmann.pl/blog/2012/12/03/configuring-polkit-in-fedora-18-to-access-virt-manager/
#polkit.addRule(function(action, subject) {
#  if (action.id == "org.libvirt.unix.manage" && subject.local && subject.active && subject.isInGroup("wheel")) {
#	   return polkit.Result.YES;
#  }
#});
#

# get the weather
function GetWeather()
{
	if [ -z "$1" ]; then
		curl http://wttr.in
	else
		curl http://wttr.in/$1
	fi
}
alias weather=GetWeather

# display git branch in prompt
# https://github.com/jimeh/git-aware-prompt
export GITAWAREPROMPT=~/.bash/git-aware-prompt
source "${GITAWAREPROMPT}/main.sh"

# colorize prompt, drop user@hostname portion because this is for my local account
export PS1="[\[\033[01;34m\]\w\[\033[00m\] \[$txtcyn\]\$git_branch\[$txtred\]\$git_dirty\[$txtrst\]]\$ "


# if we think we are in a container, let's show that
# requires use of `ENV container docker` in your containers
#export incontainer="${container:-none}"

# of course jlebon has the better solution
# https://github.com/jlebon/files/blob/master/dotfiles/.bashrc#L222
__in_dockerenv=no
if [ -f /.dockerenv ] || [ -f /run/.containerenv ]; then
    __in_dockerenv=yes
fi

if [[ "$__in_dockerenv" == yes ]]; then
    export PS1="[\[$txtred\](container) \[\033[01;34m\]\w\[\033[00m\] \[$txtcyn\]\$git_branch\[$txtred\]\$git_dirty\[$txtrst\]]\$ "
fi

# additional examples in case I change my mind
#export PS1="[\u@\h \W \[$txtcyn\]\$git_branch\[$txtred\]\$git_dirty\[$txtrst\]]\$ "
#export PS1="[\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\] \[$txtcyn\]\$git_branch\[$txtred\]\$git_dirty\[$txtrst\]]\$ "

# undefine a VM and remove the qcow2
function RemoveVm()
{
	if [ -z "$1" ]; then
		printf "Please provide a VM name\n"
	else
		STATE=$(virsh dominfo $1 | grep State | awk '{print $2}')
		if [ "$STATE" = "running" ]; then
			virsh destroy $1
		fi
		QCOW=$(virsh dumpxml $1 | grep -m 1 -F .qcow2 | cut -d "'" -f2)
		sudo rm $QCOW
		virsh undefine $1
	fi
}
alias remove-vm=RemoveVm

# get ip from vagrant box
alias vagrantip="vagrant ssh -c \"ip address show eth0 | grep 'inet ' | sed -e 's/^.*inet //' -e 's/\/.*$//'\""

# add jlebon files to PATH
export PATH="$PATH:/home/miabbott/workspaces/jlebon/files/bin"

# aliases for frequently used dirs
alias aht="pushd ~/workspaces/projectatomic/atomic-host-tests/"
alias acj="pushd ~/workspaces/atomic-ci-jobs/"

# Git tab completion
# https://github.com/git/git/blob/master/contrib/completion/git-completion.bash
source ~/git-completion.bash

# Finding SSH_AUTH_SOCK
# http://blog.joncairns.com/2013/12/understanding-ssh-agent-and-ssh-add/
# https://github.com/wwalker/ssh-find-agent
source ~/ssh-find-agent.sh
set_ssh_agent_socket

alias htop="sudo podman run -it --rm --pid=host localhost/miabbott/htop"

export GOPATH=~/workspaces/go
export PATH="$PATH:$GOPATH/bin"

# living on the edge!
alias docker="/usr/bin/podman"

# handy for doing local ostree tests
alias ost="ostree --repo=repo"

# Get latest RHCOS AMI
function rhcos()
{
   echo "--aws-type t2.small --aws-region us-east-1 --aws-ami $(curl -s http://aos-ostree.rhev-ci-vms.eng.rdu2.redhat.com/rhcos/images/cloud/latest/aws-us-east-1.json | jq -r .HVM)"
}
